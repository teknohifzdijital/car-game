<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Tabanlı 3D Sonsuz Otoyol Simülasyonu</title>
    <!-- Tailwind CSS (Arayüz ve Stil İçin) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter fontunu kullan */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Canvas tüm ekranı kaplayacağı için kaydırmayı engeller */
            background-color: #000;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
        }
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* HUD elementlerinin 3D sahne ile etkileşimi engellemesini önler */
            color: white;
            padding: 20px;
        }
        .hud-panel {
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            border-radius: 12px;
            padding: 10px 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #speed-gauge {
            font-size: 3rem;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
            color: #FF6666;
            transition: all 0.1s;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Three.js Canvas Buraya Eklenecek -->
        <div id="hud">
            <!-- Sol Üst: Skor ve Süre -->
            <div class="absolute top-5 left-5 hud-panel">
                <p class="text-sm text-gray-400">Skor</p>
                <p id="score-display" class="text-3xl font-extrabold text-yellow-400">0</p>
                
                <p class="text-sm text-gray-400 mt-3">Geçen Süre</p>
                <p id="lap-timer" class="text-xl font-mono">00:00.000</p>
            </div>
            
            <!-- Sağ Üst: Mini Harita (Pist düz olduğu için artık sadece ilerlemeyi gösterir) -->
            <div class="absolute top-5 right-5 hud-panel p-0 bg-transparent border-0">
                <p class="text-sm text-gray-400 mb-1 text-right">Otoyol Haritası</p>
                <canvas id="minimap-canvas" width="200" height="200" class="rounded-lg shadow-xl bg-gray-800 border-2 border-gray-600"></canvas>
            </div>

            <!-- Sağ Alt: Hız Göstergesi ve Devir -->
            <div class="absolute bottom-5 right-5 text-right hud-panel flex flex-col items-end">
                <div class="flex items-end space-x-4">
                    <div class="flex flex-col items-center">
                        <p id="gear-display" class="text-4xl font-extrabold text-white">N</p>
                        <p class="text-xs text-gray-400">Vites</p>
                    </div>
                    <div>
                        <p id="speed-gauge">0</p>
                        <p class="text-xl text-gray-400 mt-[-10px]">KM/H</p>
                    </div>
                </div>
                <div id="rpm-bar" class="w-full h-2 bg-gray-700 rounded-full mt-2">
                    <div id="rpm-fill" class="h-full bg-red-600 rounded-full transition-all duration-100 ease-linear" style="width: 0%;"></div>
                </div>
            </div>

            <!-- Merkezi Mesaj Kutusu -->
            <div id="message-box" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center transition-opacity duration-500 opacity-0" style="pointer-events: none;">
                <h1 id="message-text" class="text-6xl font-extrabold text-white" style="text-shadow: 0 0 15px rgba(255, 255, 255, 1);"></h1>
            </div>
        </div>
    </div>

    <!-- Kütüphane Yüklemeleri -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OBJ Model Yükleyici Eklentisi -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    
    <script type="module">
        // Bu simülasyon tek oyunculudur (offline). 

        /**
         * --------------------------------------------------
         * 1. PHYSICS.TS - Fizik Dünyası Yönetimi (Kİnematik)
         * --------------------------------------------------
         */
        class Physics {
            constructor() {
                this.gravity = 9.81; // Basit yerçekimi
            }

            // Fizik dünyası başlatma
            init() {
                console.log("Basit Kinematik Fizik Simülasyonu Başlatıldı.");
            }

            update(deltaTime) {
                // Kinematik sistemde fizik adımı yoktur.
            }
        }

        /**
         * --------------------------------------------------
         * 2. INPUTCONTROLLER.TS - Girdi Yönetimi
         * --------------------------------------------------
         */
        class InputController {
            constructor() {
                this.input = {
                    forward: 0,
                    backward: 0,
                    left: 0,
                    right: 0,
                    handbrake: 0
                };
                this.keyMap = {
                    'w': 'forward',
                    's': 'backward',
                    'a': 'left', // A tuşu Sol Hareketi temsil eder
                    'd': 'right', // D tuşu Sağ Hareketi temsil eder
                    ' ': 'handbrake'
                };
                window.addEventListener('keydown', this.onKeyChange.bind(this, 1));
                window.addEventListener('keyup', this.onKeyChange.bind(this, 0));
            }

            onKeyChange(value, event) {
                const action = this.keyMap[event.key.toLowerCase()];
                if (action) {
                    this.input[action] = value;
                    event.preventDefault();
                }
            }

            getInput() {
                return this.input;
            }
        }
        
        /**
         * --------------------------------------------------
         * 3. AIController.TS - Yapay Zeka Rakip Yönetimi
         * --------------------------------------------------
         */
        class AIController {
            constructor(vehicle, waypoints, difficulty = 1.0) {
                this.vehicle = vehicle;
                // Düz yolda AI takibi için yapay bir uzak hedef noktası (Z ekseninde ileri)
                this.targetWaypoint = new THREE.Vector3(0, 0, 5000); 
                
                // AI'nın oyuncu tarafından sollanıp sollanmadığını tutar
                this.isOvertaken = false; 
                
                // Zorluk, hız ve hassasiyet çarpanlarını ayarlar
                this.difficulty = difficulty; 
                
                // Hız artırıldı: AI'lar artık maks. hızın %70'inden %90'ına kadar çıkabilir.
                this.targetSpeedFactor = 0.7 + (difficulty * 0.2); 
                
                this.arrivalThreshold = 50; 
                this.aiInput = { forward: 0, backward: 0, left: 0, right: 0, handbrake: 0 };
            }

            update(deltaTime) {
                const currentPos = this.vehicle.mesh.position;
                const targetPos = this.targetWaypoint;
                
                const distanceToTarget = currentPos.distanceTo(targetPos);
                
                // 1. Hız Kontrolü (Gaz/Fren)
                let targetSpeed = this.vehicle.maxSpeed * this.targetSpeedFactor; 

                // Hız limitini koru
                if (this.vehicle.speed < targetSpeed) {
                    this.aiInput.forward = 1; 
                    this.aiInput.backward = 0;
                } else if (this.vehicle.speed > targetSpeed * 1.05) {
                    this.aiInput.forward = 0;
                    this.aiInput.backward = 1; // Fren
                } else {
                    this.aiInput.forward = 0;
                    this.aiInput.backward = 0;
                }
                
                // 2. Direksiyon Kontrolü (Düz Sürüş ve Şerit Koruma)
                
                // Mevcut X pozisyonuna bağlı olarak orta şeride (initialX) dönmeye çalış
                const targetX = this.vehicle.mesh.userData.initialX || 0; // AI'nın başlangıç X konumu
                const centerError = targetX - currentPos.x;
                
                // Orta şeride dönmeye çalışan direksiyon açısı (Düz sürüş için rastgele sapma kaldırıldı)
                let steering = centerError * 0.08; // Daha agresif şerit düzeltme
                
                // Direksiyon açısı sınırlandırma
                steering = Math.max(-1, Math.min(1, steering));

                this.aiInput.left = Math.max(0, -steering);
                this.aiInput.right = Math.max(0, steering);
                this.aiInput.handbrake = 0;

                // AI aracını güncelle
                this.vehicle.update(this.aiInput, deltaTime);

                // 3. Waypoint Güncelleme (Hedef noktaya yaklaşırsak hedefi ileri taşı)
                if (distanceToTarget < this.arrivalThreshold) {
                    this.targetWaypoint.z += 5000; // Hedefi çok daha ileri taşı
                }
            }
            
            resetOvertakeStatus() {
                // Artık Game sınıfında anlık kontrol yapılıyor
            }
        }


        /**
         * --------------------------------------------------
         * 4. ENTITIES/VEHICLE.TS - Araç Sınıfı (Oyuncu Aracı)
         * --------------------------------------------------
         */
        class Vehicle {
            // carModelGroup, Game.CarModelGroup'dan gelen yüklü 3D model grubudur
            constructor(scene, color = 0x00aaff, startPos = new THREE.Vector3(0, 0.3, 0), id = 'player', carModelGroup) {
                this.scene = scene;
                this.id = id;
                
                // HIZ AYARLARI: Maksimum 600 km/h (m/s)
                this.maxSpeed = 600 / 3.6; 
                this.acceleration = 50; 
                this.maxSteeringAngle = Math.PI / 6; 
                this.turnRate = 1.8; 
                this.dragFactor = 0.3; 

                // Kinematik Durum
                this.speed = 0; // Mevcut hız (m/s)
                this.steeringAngle = 0; // Mevcut direksiyon açısı

                // Three.js Mesh'i oluştur (OBJ model veya yer tutucu kutu)
                if (carModelGroup && carModelGroup !== 'placeholder') {
                    // Yüklü 3D modeli klonla
                    this.mesh = carModelGroup.clone();
                    
                    // Klonlanmış mesh'in materyal renklerini araç rengine göre ayarla
                    this.mesh.traverse(function (child) {
                        if (child instanceof THREE.Mesh) {
                            child.material = child.material.clone();
                            child.material.color.set(color);
                            child.castShadow = true;
                        }
                    });
                    
                } else {
                    // Model yüklenemediyse veya 'placeholder' ise yer tutucu BoxGeometry kullan
                    // KÜÇÜK KUTU BOYUTU: 1.5 genişlik, 0.6 yükseklik, 3.0 uzunluk
                    const carGeometry = new THREE.BoxGeometry(1.5, 0.6, 3.0); 
                    const carMaterial = new THREE.MeshPhongMaterial({ color: color, flatShading: true });
                    this.mesh = new THREE.Mesh(carGeometry, carMaterial);
                }
                
                this.mesh.position.copy(startPos); 
                // Oyuncu aracı ileri (Negatif Z) yöne baksın
                this.mesh.rotation.y = 0; 
                scene.add(this.mesh);
                
                // AI için başlangıç X konumunu kaydet
                this.mesh.userData.initialX = startPos.x;
                // Yol dışı çarpışma durumunu Game sınıfına iletmek için
                this.mesh.userData.offRoadCollision = false; 

                console.log(`Araç oluşturuldu: ${id} (Kinematik Kontrol).`);
            }

            update(input, deltaTime) {
                // 1. Hızlanma/Frenleme
                const throttle = input.forward - input.backward;
                
                if (throttle !== 0) {
                    this.speed += throttle * this.acceleration * deltaTime;
                } else {
                    // Sürünme (Drag/Yavaşlama)
                    this.speed *= (1 - this.dragFactor * deltaTime);
                }
                
                // 2. El Freni
                if (input.handbrake) {
                    this.speed *= (1 - 3.0 * deltaTime); // Sert yavaşlama
                }
                
                // 3. Hız Sınırı
                this.speed = Math.max(0, Math.min(this.maxSpeed, this.speed));
                
                if (this.speed < 0.05) this.speed = 0; // Çok yavaşsa durdur

                // 4. Direksiyon Açısı
                // FIX: Kullanıcının talebi üzerine sol/sağ girdisi ters çevrildi (A=Sol, D=Sağ)
                const targetSteering = (input.left - input.right) * this.maxSteeringAngle;
                // Yumuşak direksiyon geçişi
                this.steeringAngle += (targetSteering - this.steeringAngle) * 5 * deltaTime;


                // 5. Rotasyon ve Pozisyon Güncelleme
                if (this.speed > 0 || Math.abs(this.steeringAngle) > 0.01) {
                    // Rotasyonu uygula
                    const turnFactor = Math.min(1, this.speed / (this.maxSpeed * 0.5)); 
                    // Düz yolda oyuncu aracı X ekseni etrafında dönsün (Yani Z ekseni)
                    this.mesh.rotation.y -= this.steeringAngle * this.turnRate * turnFactor * deltaTime;

                    // İleri vektörü hesapla (Düz yolda Z ekseni ileri)
                    const forwardDirection = new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion);

                    // Pozisyonu güncelle (yeni hız * zaman * yön)
                    const displacement = forwardDirection.multiplyScalar(this.speed * deltaTime);
                    this.mesh.position.add(displacement);
                }

                // 6. Basit Yerçekimi/Zemin Teması ve Yol Dışı Cezası (Bariyerler)
                this.mesh.position.y = 0.3; 
                
                // Yol sınırları X: -20 ile X: 20 arası (4 Şeritli Ana yol)
                const roadBoundary = 20; 
                const barrierBoundary = 20.5; // Bariyerin başladığı yerin hemen dışı (çarpma sınırı)

                if (Math.abs(this.mesh.position.x) > roadBoundary) {
                    // Yol sınırında veya dışında yavaşlatıcı etki uygula
                    this.speed *= (1 - 1.5 * deltaTime); 
                    this.speed = Math.max(0, this.speed);
                    
                    // Bariyer dışına çıkarsa (Çevre çarpması)
                    if (Math.abs(this.mesh.position.x) > barrierBoundary) {
                        // Geri ışınlanma Game sınıfında yapılacak
                        this.mesh.userData.offRoadCollision = true;
                    } else {
                        this.mesh.userData.offRoadCollision = false;
                    }
                } else {
                    this.mesh.userData.offRoadCollision = false;
                }
            }
            
            getSpeed() {
                return this.speed;
            }
        }
        
        /**
         * --------------------------------------------------
         * 5. MINIMAP.TS - Mini Harita Çizim Yönetimi
         * --------------------------------------------------
         */
        class Minimap {
            constructor(canvasId, trackExtents) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                this.trackExtents = trackExtents; 
                
                // Mini harita ölçeği: X ekseni [-25, 25] aralığına göre ayarlanır (Toplam 50 birim)
                this.mapScale = this.width / (trackExtents.max - trackExtents.min); 
            }
            
            // 3D koordinatı 2D canvas koordinatına dönüştürür (Sadece X-ekseni için şerit takibi)
            worldToMap(x, z) {
                // X koordinatını [0, 50] aralığına kaydır (-25'ten +25'e)
                const normalizedX = x - this.trackExtents.min;
                
                // X pozisyonunu yatay olarak harita üzerine yansıt (mapX)
                const mapX = normalizedX * this.mapScale;
                
                // Z (ileri/geri) koordinatını haritanın sabit bir dikey pozisyonuna sabitleyelim
                const mapY = this.height / 2; 
                
                return { x: mapX, y: mapY };
            }

            draw(playerPos, aiPositions) {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // 1. Otoyol Genişliği Çizimi (Şerit Görünümü - X-ekseni)
                this.ctx.fillStyle = '#1f2937'; // Gri arka plan
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // Orta Çizgi (Haritanın tam ortası)
                this.ctx.strokeStyle = '#4b5563'; 
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.height / 2);
                this.ctx.lineTo(this.width, this.height / 2);
                this.ctx.stroke();

                // 2. AI Araçlarını Çiz (Noktalar)
                aiPositions.forEach((pos, index) => {
                    // X pozisyonunu kullanıyoruz
                    const mapCoord = this.worldToMap(pos.x, pos.z); 
                    
                    // Renge göre belirle 
                    const color = index === 0 ? '#AA00AA' : index === 1 ? '#00FF00' : '#FF0000'; 
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(mapCoord.x, mapCoord.y, 4, 0, Math.PI * 2); 
                    this.ctx.fill();
                });
                
                // 3. Oyuncu Aracını Çiz (Büyük Mavi Nokta)
                // Oyuncunun X koordinatını kullanıyoruz
                const playerMapCoord = this.worldToMap(playerPos.x, playerPos.z);
                this.ctx.fillStyle = '#00aaff';
                this.ctx.beginPath();
                this.ctx.arc(playerMapCoord.x, playerMapCoord.y, 6, 0, Math.PI * 2); 
                this.ctx.fill();
            }
        }


        /**
         * --------------------------------------------------
         * 6. SCENEMANAGER.TS - Sahne Yönetimi (Three.js)
         * --------------------------------------------------
         */
        class SceneManager {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                document.getElementById('game-container').appendChild(this.renderer.domElement);
                
                this.waypoints = [
                    new THREE.Vector3( 0, 0, 5000), 
                ]; 
                // Yol genişliği X: -25 ile X: 25 arası (Harita çizimi için)
                this.trackExtents = { min: -25, max: 25 }; 
                this.setupScene();
                window.addEventListener('resize', this.onWindowResize.bind(this));
            }

            setupScene() {
                // Işıklandırma
                const sun = new THREE.DirectionalLight(0xffffff, 1.5);
                sun.position.set(200, 400, 200);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 2048;
                sun.shadow.mapSize.height = 2048;
                this.scene.add(sun);
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.5)); 

                // 1. Yeşil Çimenlik Zemin (Grass)
                const groundGeometry = new THREE.BoxGeometry(1000, 0.2, 1000);
                const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x335533 }); 
                const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
                groundMesh.position.y = -0.1;
                groundMesh.receiveShadow = true;
                this.scene.add(groundMesh);

                // 2. OTOYOL (4 ŞERİTLİ ANA YOL)
                const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 }); 
                const roadWidth = 40; // Ana yol genişliği 40 birim (4 şerit için)
                const trackLength = 10000; 

                const roadGeometry = new THREE.BoxGeometry(roadWidth, 0.05, trackLength);
                const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
                roadMesh.position.set(0, 0.05, trackLength / 2 - 5000); 
                roadMesh.receiveShadow = true;
                this.scene.add(roadMesh);
                
                // 3. Şerit Çizgileri (4 şerit için 3 kesintili çizgi)
                const centerLineMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
                const laneWidth = roadWidth / 4; // Her şerit 10 birim
                const lineGap = 20;
                const lineLength = 10;
                const centerlineThickness = 0.5;

                // Çizgi Pozisyonları: -10, 0, 10
                const linePositions = [-laneWidth, 0, laneWidth]; 

                for (const xPos of linePositions) {
                    for (let i = -trackLength/2; i < trackLength/2; i += lineGap) {
                        const line = new THREE.Mesh(new THREE.BoxGeometry(centerlineThickness, 0.07, lineLength), centerLineMaterial);
                        line.position.set(xPos, 0.07, i); // Orta çizgiler X=-10, X=0, X=10
                        this.scene.add(line);
                    }
                }

                // 4. Yol Sınır Çizgileri (Yolun en kenarları)
                const boundaryLineMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00 }); // Sarı çizgi
                const boundaryThickness = 0.3;
                const boundaryLinePositions = [-roadWidth/2, roadWidth/2]; // -20 ve 20

                for (const xPos of boundaryLinePositions) {
                    for (let i = -trackLength/2; i < trackLength/2; i += lineGap) {
                        const line = new THREE.Mesh(new THREE.BoxGeometry(boundaryThickness, 0.07, lineLength), boundaryLineMaterial);
                        line.position.set(xPos, 0.07, i);
                        this.scene.add(line);
                    }
                }
                
                // 5. GÜVENLİK BARİYERLERİ (Demirler)
                const barrierGeometry = new THREE.BoxGeometry(0.5, 1.5, trackLength); // Yüksek ve ince
                const barrierMaterial = new THREE.MeshStandardMaterial({ color: 0xAAAAAA }); // Gümüş gri
                const barrierOffset = roadWidth / 2 + 0.25; // 20.25

                // Sol Bariyer (X: -20.25)
                const barrierLMesh = new THREE.Mesh(barrierGeometry, barrierMaterial);
                barrierLMesh.position.set(-barrierOffset, 0.75, trackLength / 2 - 5000); 
                this.scene.add(barrierLMesh);

                // Sağ Bariyer (X: 20.25)
                const barrierRMesh = new THREE.Mesh(barrierGeometry, barrierMaterial);
                barrierRMesh.position.set(barrierOffset, 0.75, trackLength / 2 - 5000); 
                this.scene.add(barrierRMesh);


                // Basit Skybox (Gökyüzü)
                this.scene.background = new THREE.Color(0x87ceeb);
                
                // Kamera Konumu (Başlangıç)
                this.camera.position.set(0, 10, -20);
                this.camera.lookAt(0, 0, 0);
            }
            
            // Kamerayı araca takip ettir (Kuş Bakışı)
            updateCamera(targetMesh) {
                // KUŞ BAKIŞI KAMERA AYARI (Yüksek ve geride)
                const offset = new THREE.Vector3(0, 15, -15); // Y: 15 birim yükseklik, Z: -15 birim geride
                offset.applyQuaternion(targetMesh.quaternion);

                const targetPosition = new THREE.Vector3().copy(targetMesh.position).add(offset);
                this.camera.position.lerp(targetPosition, 0.1);
                
                // Biraz ilerideki bir noktaya bak
                const lookAtOffset = new THREE.Vector3(0, 0, 5);
                lookAtOffset.applyQuaternion(targetMesh.quaternion);
                const lookAtPoint = new THREE.Vector3().copy(targetMesh.position).add(lookAtOffset);

                this.camera.lookAt(lookAtPoint);
            }

            getWaypoints() {
                return this.waypoints; 
            }
            
            getTrackExtents() {
                return this.trackExtents; 
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        /**
         * --------------------------------------------------
         * 7. UIMANAGER.TS - Kullanıcı Arayüzü Yönetimi
         * --------------------------------------------------
         */
        class UIManager {
            constructor() {
                this.scoreEl = document.getElementById('score-display'); 
                this.lapTimerEl = document.getElementById('lap-timer');
                this.speedGaugeEl = document.getElementById('speed-gauge');
                this.gearDisplayEl = document.getElementById('gear-display');
                this.rpmFillEl = document.getElementById('rpm-fill');
                this.messageBox = document.getElementById('message-box');
                this.messageText = document.getElementById('message-text');

                this.startTime = Date.now();
                this.elapsedTime = 0;
            }

            updateHUD(speed, maxSpeed, rpmRatio, gear, score) {
                // Skor Güncelleme
                this.scoreEl.textContent = score.toString(); 
                
                // Hız Güncelleme (m/s'den km/h'e)
                const currentSpeedKmH = Math.round(speed * 3.6); 
                this.speedGaugeEl.textContent = currentSpeedKmH;
                
                // Devir Güncelleme
                this.rpmFillEl.style.width = `${Math.min(100, Math.max(0, rpmRatio * 100))}%`;
                
                // Vites Güncelleme
                this.gearDisplayEl.textContent = gear;

                // Zamanlayıcı Güncelleme (Geçen Süre)
                this.elapsedTime = Date.now() - this.startTime;
                const totalSeconds = Math.floor(this.elapsedTime / 1000);
                const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
                const seconds = (totalSeconds % 60).toString().padStart(2, '0');
                const milliseconds = (this.elapsedTime % 1000).toString().padStart(3, '0');
                this.lapTimerEl.textContent = `${minutes}:${seconds}.${milliseconds}`;
            }

            showMessage(text, duration = 2000) {
                this.messageText.textContent = text;
                this.messageBox.style.opacity = '1';
                if (duration > 0) {
                    setTimeout(() => {
                        this.messageBox.style.opacity = '0';
                    }, duration);
                }
            }
        }
        
        /**
         * --------------------------------------------------
         * 8. APP/GAME.TS - Oyunun Ana Sınıfı
         * --------------------------------------------------
         */
        class Game {
            constructor() {
                this.sceneManager = new SceneManager();
                this.physics = new Physics();
                this.inputController = new InputController();
                this.uiManager = new UIManager();
                
                this.lastTime = 0;
                this.playerVehicle = null;
                this.aiControllers = []; 
                this.minimap = null; 
                this.carModelGroup = null; // Yüklü 3D modeli tutacak değişken
                
                this.score = 0; 
                
                this.isGameRunning = false;
            }

            /**
             * Harici 3D araç modelini (car1.obj) yükler.
             */
            async loadCarModel() {
                return new Promise((resolve) => {
                    const loader = new THREE.OBJLoader();
                    
                    // Kullanıcının istediği dosya adı
                    const modelPath = 'car1.obj'; 

                    loader.load(
                        modelPath,
                        (object) => {
                            // Model yüklendiğinde
                            object.traverse(function (child) {
                                if (child instanceof THREE.Mesh) {
                                    // Gölgelendirme ve materyal ayarları (Basit Phong materyal)
                                    child.material = new THREE.MeshPhongMaterial({ 
                                        color: 0x888888, // Varsayılan gri
                                        flatShading: true 
                                    });
                                    child.castShadow = true;
                                }
                            });
                            
                            // YENİ KÜÇÜK ÖLÇEK
                            const scaleFactor = 0.3; 
                            object.scale.set(scaleFactor, scaleFactor, scaleFactor);
                            object.rotation.y = Math.PI; // Modelin Z ekseninde ileri bakması için 180 derece döndür.
                            object.position.y = -0.3; // Mesh'in tabanını yeni y=0.3'e oturtmak için
                            
                            this.carModelGroup = object;
                            console.log("3D Araba Modeli Yüklendi:", modelPath);
                            resolve();
                        },
                        // Yükleme sırasında (İlerlemeyi konsola yazdır)
                        (xhr) => {
                            this.uiManager.showMessage(`Model Yükleniyor: ${(xhr.loaded / xhr.total * 100).toFixed(0)}%`, 0);
                        },
                        // Hata durumunda (Yer tutucuya geri dön)
                        (error) => {
                            console.error(`HATA: Model yüklenirken hata oluştu: ${error.message}. Kutu geometrisi kullanılacak.`);
                            this.carModelGroup = 'placeholder'; 
                            resolve(); 
                        }
                    );
                });
            }


            async init() {
                this.uiManager.showMessage("3D Model Yükleniyor...", 0); 
                await this.loadCarModel(); // Asenkron yükleme bekle

                this.physics.init(); 
                const waypoints = this.sceneManager.getWaypoints();

                // 1. Oyuncu Aracını Oluştur (Mavi - 4 şeritli yolun 3. şeridi)
                // Şerit pozisyonları: -15, -5, 5, 15
                this.playerVehicle = new Vehicle(this.sceneManager.scene, 0x00aaff, new THREE.Vector3(5, 0.3, 0), 'player', this.carModelGroup); 
                this.sceneManager.camera.lookAt(this.playerVehicle.mesh.position);
                
                // 2. AI Rakipleri Oluştur
                this.createAIOpponents(waypoints, this.carModelGroup);
                
                // 3. Mini Haritayı Başlat
                this.minimap = new Minimap('minimap-canvas', this.sceneManager.getTrackExtents());

                this.isGameRunning = true;
                this.uiManager.showMessage("Dört Şeritli Otoyol! Sollama Yap ve Puan Kazan!", 3000);
                console.log("Oyun Başlatıldı (Sonsuz Otoyol Modu).");

                // Ana oyun döngüsünü başlat
                this.sceneManager.renderer.setAnimationLoop(this.update.bind(this));
            }
            
            // carModelGroup parametresini ekle
            createAIOpponents(waypoints, carModelGroup) {
                // 4 Şerit Pozisyonları: -15 (En Sol), -5, 5 (Oyuncununki), 15 (En Sağ)
                
                // AI 1 (Kolay - Mor - En Sol Şerit: -15)
                const aiVehicle1 = new Vehicle(this.sceneManager.scene, 0xAA00AA, new THREE.Vector3(-15, 0.3, 100), 'ai-1', carModelGroup); 
                // Difficulty 0.9: Daha yavaş ve düz gitmeye odaklı
                const aiController1 = new AIController(aiVehicle1, waypoints, 0.9); 
                this.aiControllers.push(aiController1);

                // AI 2 (Orta - Yeşil - İkinci Şerit: -5)
                const aiVehicle2 = new Vehicle(this.sceneManager.scene, 0x00FF00, new THREE.Vector3(-5, 0.3, 200), 'ai-2', carModelGroup);
                // Difficulty 1.1: Biraz daha hızlı ve düz
                const aiController2 = new AIController(aiVehicle2, waypoints, 1.1); 
                this.aiControllers.push(aiController2);
                
                // Yeni AI 3 (Zor - Kırmızı - En Sağ Şerit: 15)
                const aiVehicle3 = new Vehicle(this.sceneManager.scene, 0xFF0000, new THREE.Vector3(15, 0.3, 350), 'ai-3', carModelGroup);
                // Difficulty 1.3: En hızlı ve en düz
                const aiController3 = new AIController(aiVehicle3, waypoints, 1.3); 
                this.aiControllers.push(aiController3);
            }

            /**
             * Oyuncu aracının AI'larla veya yol dışı çevre ile çarpışmasını kontrol eder.
             */
            checkCollisions() {
                const playerPos = this.playerVehicle.mesh.position;
                // YENİ KÜÇÜK ÇARPIŞMA KUTUSU: 1.5 genişlik, 3.0 uzunluk
                const playerBox = { width: 1.5, length: 3.0 }; 

                // 1. AI Çarpışma Kontrolü
                for (const aiController of this.aiControllers) {
                    const aiPos = aiController.vehicle.mesh.position;
                    const aiBox = { width: 1.5, length: 3.0 }; 
                    
                    // Basit AABB (Axis-Aligned Bounding Box) kontrolü
                    // X ekseninde çarpışma (Yatay)
                    const collisionX = Math.abs(playerPos.x - aiPos.x) < (playerBox.width / 2 + aiBox.width / 2); // 1.5
                    // Z ekseninde çarpışma (Dikey/İleri)
                    const collisionZ = Math.abs(playerPos.z - aiPos.z) < (playerBox.length / 2 + aiBox.length / 2); // 3.0
                    
                    if (collisionX && collisionZ) {
                        // Çarpışma tespit edildi!
                        this.handleCollision("AI çarpması");
                        return; // Çarpışma varsa döngüden çık
                    }
                }
                
                // 2. Çevre Çarpışma Kontrolü (Bariyer)
                if (this.playerVehicle.mesh.userData.offRoadCollision) {
                    this.handleCollision("Bariyer çarpması");
                }
            }

            /**
             * Çarpışma durumunu işler, oyuncuyu spawna ışınlar ve ceza uygular.
             * @param {string} reason - Çarpışma nedeni
             */
            handleCollision(reason) {
                if (!this.isGameRunning) return;
                
                console.log(`Çarpışma: ${reason}. Oyuncu ışınlanıyor.`);
                this.isGameRunning = false; // Kısa süreliğine oyunu durdur
                
                // 1. Işınlanma (Oyuncuyu Lane 3'e ışınla)
                this.playerVehicle.mesh.position.set(5, 0.3, 0); 
                this.playerVehicle.speed = 0;
                this.playerVehicle.steeringAngle = 0;
                
                // AI'ları da oyuncu ile çakışmayacakları bir yere ışınla
                this.aiControllers.forEach((controller, index) => {
                    // AI'ları kendi şeritlerine ve Z=0'dan biraz uzağa koy
                    const initialX = [ -15, -5, 15 ][index]; // AI'ların başlangıç X pozisyonları
                    controller.vehicle.mesh.position.set(initialX, 0.3, Math.random() * 100 + 50); 
                    controller.vehicle.speed = 0;
                });

                // 2. Skor Cezası
                this.score = Math.max(0, this.score - 50);
                
                // 3. Mesaj Göster
                this.uiManager.showMessage(`ÇARPIŞMA! Işınlanıyorsun. (-50 Skor)`, 2000);
                
                // 4. Kısa bir süre sonra oyunu devam ettir
                setTimeout(() => {
                    this.isGameRunning = true;
                }, 1500); 
            }
            
            checkOvertakes() {
                const playerPos = this.playerVehicle.mesh.position;
                
                this.aiControllers.forEach(aiController => {
                    const aiPos = aiController.vehicle.mesh.position;
                    
                    // Sollama kontrolü
                    const isAhead = playerPos.z > aiPos.z + 5;
                    const isLatallyClose = Math.abs(playerPos.x - aiPos.x) < 40; // Geniş yolun sınırları içinde

                    if (isAhead && isLatallyClose && !aiController.isOvertaken) {
                        this.score += 100;
                        aiController.isOvertaken = true;
                        this.uiManager.showMessage(`+100 Puan! Rakip ${aiController.vehicle.id} Sollanmıştır!`, 1500);
                    }
                    
                    // Oyuncu araçtan 100 birimden fazla uzaklaştıysa, sollama durumunu sıfırla
                    if (playerPos.z > aiPos.z + 100) {
                         aiController.isOvertaken = false;
                    }
                });
            }


            update(time) {
                if (!this.isGameRunning) return;

                const deltaTime = (time - this.lastTime) / 1000;
                this.lastTime = time;

                const input = this.inputController.getInput();
                
                // 1. Fizik Güncellemesi (Kinematik)
                this.physics.update(deltaTime);
                
                // 2. Oyuncu Aracını Güncelle
                this.playerVehicle.update(input, deltaTime);

                // 3. AI Rakipleri Güncelle
                this.aiControllers.forEach(controller => {
                    controller.update(deltaTime);
                });
                
                // YENİ: Çarpışma Kontrolü ve Işınlanma
                this.checkCollisions();

                // 4. Sollama Kontrolü ve Skor Güncellemesi
                this.checkOvertakes();

                // 5. Kamera Güncellemesi
                this.sceneManager.updateCamera(this.playerVehicle.mesh);
                
                // 6. HUD Güncellemesi
                const speedMps = this.playerVehicle.getSpeed();
                const maxSpeedMps = this.playerVehicle.maxSpeed;
                const rpmRatio = speedMps / maxSpeedMps;
                
                // Basit vites hesaplaması
                let gear = 'N';
                if (input.forward > 0 && speedMps > 0.1) gear = 'D1';
                else if (input.backward > 0 && speedMps > 0.1) gear = 'R';
                else if (speedMps > 0.1) gear = 'D'; 
                
                // Tur bilgisi olmadan güncelle
                this.uiManager.updateHUD(speedMps, maxSpeedMps, rpmRatio, gear, this.score);
                
                // 7. Mini Harita Güncellemesi
                const playerMapData = {
                    x: this.playerVehicle.mesh.position.x, 
                    z: this.playerVehicle.mesh.position.z,
                    rotation: this.playerVehicle.mesh.quaternion 
                };
                const aiMapPositions = this.aiControllers.map(c => c.vehicle.mesh.position);
                this.minimap.draw(playerMapData, aiMapPositions, this.sceneManager.getWaypoints());


                // 8. Render
                this.sceneManager.renderer.render(this.sceneManager.scene, this.sceneManager.camera);
            }
        }

        // DOM yüklendikten sonra oyunu başlat
        window.onload = () => {
            const game = new Game();
            game.init();
        };

    </script>
</body>
</html>
